---
phase: 05-session-state-machine-orchestration
plan: 03
type: execute
wave: 3
depends_on:
  - 05-02
files_modified:
  - src/lib/ws/message-types.ts
  - src/lib/ws/session-handler.ts
autonomous: true
requirements:
  - SESS-01
  - SESS-06

must_haves:
  truths:
    - "WebSocket handler creates and runs SessionOrchestrator when start_session is received"
    - "Client receives phase_start messages at the beginning of each session phase"
    - "Client receives phase_transition messages when phases change"
    - "Orchestrator text sentences flow through TTS pipeline to produce audio for the client"
    - "Pause/resume and abort controls work with the orchestrator-driven pipeline"
    - "Session state is initialized in Redis when session starts"
  artifacts:
    - path: "src/lib/ws/message-types.ts"
      provides: "Extended ServerMessage with phase_start and phase_transition types"
      exports: ["ServerMessage", "ClientMessage", "parseClientMessage", "serializeServerMessage"]
    - path: "src/lib/ws/session-handler.ts"
      provides: "Orchestrator-integrated session lifecycle handler"
      exports: ["handleSession"]
  key_links:
    - from: "src/lib/ws/session-handler.ts"
      to: "src/lib/session/orchestrator.ts"
      via: "creates SessionOrchestrator and iterates run() generator"
      pattern: "new SessionOrchestrator|orchestrator\\.run"
    - from: "src/lib/ws/session-handler.ts"
      to: "src/lib/tts/tts-service.ts"
      via: "calls synthesizeSentence for each orchestrator sentence event"
      pattern: "synthesizeSentence"
    - from: "src/lib/ws/session-handler.ts"
      to: "src/lib/session-store.ts"
      via: "initializes session state in Redis on start_session"
      pattern: "setSessionState"
    - from: "src/lib/ws/message-types.ts"
      to: "ServerMessage type"
      via: "adds phase_start and phase_transition to discriminated union"
      pattern: "type:\\s*\"phase_start\"|type:\\s*\"phase_transition\""
---

<objective>
Wire the SessionOrchestrator into the WebSocket handler, replacing the direct `streamSessionAudio` pipeline call with orchestrator-driven multi-phase session flow, and extend message types for phase awareness.

Purpose: Connect the orchestrator (Plan 02) to the client-facing WebSocket layer so users experience the structured 5-phase session. The handler feeds orchestrator text events through the TTS pipeline and forwards phase metadata to the client.

Output: Updated message-types.ts with phase events, and session-handler.ts refactored to use SessionOrchestrator.
</objective>

<execution_context>
@/Users/torbjorntest/.claude/get-shit-done/workflows/execute-plan.md
@/Users/torbjorntest/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-session-state-machine-orchestration/05-RESEARCH.md
@.planning/phases/05-session-state-machine-orchestration/05-02-SUMMARY.md

@src/lib/ws/session-handler.ts (current handler to refactor)
@src/lib/ws/message-types.ts (current message types to extend)
@src/lib/tts/tts-service.ts (synthesizeSentence for per-sentence TTS)
@src/lib/session-store.ts (setSessionState for Redis persistence)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend WebSocket message types with phase events</name>
  <files>src/lib/ws/message-types.ts</files>
  <action>
Add two new ServerMessage variants for phase awareness:

1. Add to the `ServerMessage` discriminated union:
   - `| { type: "phase_start"; phase: string; phaseIndex: number }` -- sent when a new phase begins (phase is the SessionPhase string, phaseIndex is 0-4)
   - `| { type: "phase_transition"; from: string; to: string }` -- sent when transitioning between phases (from/to are SessionPhase strings)

2. Keep all existing ServerMessage variants unchanged (session_start, text, sentence_end, session_end, error).

3. The `serializeServerMessage` function already uses `JSON.stringify(message)` so it handles the new variants automatically -- no changes needed.

4. Do NOT import SessionPhase here -- use `string` for the phase fields to keep message-types.ts dependency-free (it's a protocol layer, not a domain layer). The handler will pass the correct SessionPhase strings.

Note: `parseClientMessage` and `ClientMessage` are unchanged. The client does not send phase-related messages.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Verify ServerMessage union includes `phase_start` and `phase_transition` variants. Verify `serializeServerMessage({ type: "phase_start", phase: "atmosphere", phaseIndex: 0 })` produces valid JSON.</verify>
  <done>ServerMessage type includes phase_start and phase_transition variants. Message protocol supports phase-aware client communication.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor session handler to use SessionOrchestrator</name>
  <files>src/lib/ws/session-handler.ts</files>
  <action>
Refactor the `start_session` case in `handleSession` to use `SessionOrchestrator` instead of directly calling `streamSessionAudio`. The pause/resume/end logic and connection lifecycle remain the same.

**Changes:**

1. Add imports at the top:
   - `import { SessionOrchestrator, type OrchestratorEvent } from "@/lib/session"` (or dynamic import to match existing pattern)
   - `import { synthesizeSentence } from "@/lib/tts/tts-service"` (or dynamic import)
   - `import { setSessionState, getSessionState } from "@/lib/session-store"`

2. Remove the local `AudioChunkEvent` type definition (lines 25-29) -- no longer needed since we're not consuming streamSessionAudio directly.

3. Replace the `start_session` case with orchestrator-driven flow:
   ```
   case "start_session": {
     if (isStreaming) { ... same guard ... }
     isStreaming = true;

     try {
       // Dynamic imports to avoid circular dependencies
       const { SessionOrchestrator } = await import("@/lib/session");
       const { synthesizeSentence } = await import("@/lib/tts/tts-service");

       const orchestrator = new SessionOrchestrator({
         sessionId,
         sessionLengthMinutes: 15, // Default; Phase 7 will add client-selected length
       });

       let previousText = "";
       let sentenceIndex = 0;

       for await (const event of orchestrator.run(controller.signal)) {
         if (controller.signal.aborted) break;

         // Pause gate (same pattern as before)
         while (isPaused && !controller.signal.aborted) {
           await new Promise<void>((resolve) => { resumeResolve = resolve; });
         }
         if (controller.signal.aborted) break;

         switch (event.type) {
           case "phase_start":
             send(client, { type: "phase_start", phase: event.phase, phaseIndex: event.phaseIndex });
             break;

           case "sentence":
             // Forward sentence text to client
             send(client, { type: "text", data: event.text, index: event.index });

             // Synthesize sentence to audio and stream to client
             for await (const audioChunk of synthesizeSentence(event.text, {
               previousText: previousText.slice(-1000),
               signal: controller.signal,
             })) {
               sendBinary(client, audioChunk);
             }

             // Emit sentence end marker
             send(client, { type: "sentence_end", index: event.index });

             // Track text for TTS prosody context
             previousText += " " + event.text;
             sentenceIndex++;
             break;

           case "phase_transition":
             send(client, { type: "phase_transition", from: event.from, to: event.to });
             break;

           case "session_complete":
             send(client, { type: "session_end" });
             break;

           case "error":
             send(client, { type: "error", message: event.message });
             break;
         }
       }
     } catch (err) {
       // Same error handling as before: ignore AbortError, log others
       if (err instanceof Error && err.name !== "AbortError") {
         console.error(`[ws:${sessionId}] Pipeline error:`, err);
         send(client, { type: "error", message: "Session pipeline error" });
       }
     } finally {
       isStreaming = false;
     }
     break;
   }
   ```

4. Keep the `pause`, `resume`, `end` cases EXACTLY as they are -- the pause gate pattern works identically with the orchestrator generator.

5. Keep the `close` and `error` handlers EXACTLY as they are -- the AbortController pattern propagates through the orchestrator.

6. Keep `send`, `sendBinary`, `isTextMessage` helper functions EXACTLY as they are.

**Key integration decisions:**
- The orchestrator yields text; the handler calls `synthesizeSentence` directly (not `streamSessionAudio`). This is per Research Open Question 3: orchestrator yields text, handler drives TTS.
- `previousText` tracking for TTS prosody context continues across phases (not reset per phase) since the voice should have continuity.
- Session length hardcoded to 15 minutes for now. Phase 7 (Session UX & Controls) adds client-selected session length.
- Dynamic imports used for `@/lib/session` and `@/lib/tts/tts-service` to match the existing pattern and avoid circular dependencies.
  </action>
  <verify>Run `npx tsc --noEmit` -- no type errors. Verify session-handler.ts imports SessionOrchestrator (dynamically). Verify the start_session case creates an orchestrator and iterates its run() method. Verify pause gate is present inside the orchestrator event loop. Verify synthesizeSentence is called for each sentence event.</verify>
  <done>WebSocket handler creates SessionOrchestrator on start_session, feeds orchestrator text events through TTS, forwards phase_start and phase_transition messages to client, and maintains existing pause/resume/end behavior.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. ServerMessage type includes `phase_start` and `phase_transition` variants
3. session-handler.ts no longer imports or references `streamSessionAudio` directly
4. session-handler.ts creates `SessionOrchestrator` on start_session
5. Orchestrator events are properly routed: phase_start -> send phase_start, sentence -> TTS + send text + send sentence_end, phase_transition -> send phase_transition, session_complete -> send session_end
6. Pause gate is inside the orchestrator event loop (not removed)
7. AbortController signal propagates to orchestrator.run()
8. close/error handlers still call controller.abort()
9. synthesizeSentence called for each sentence with previousText context
</verification>

<success_criteria>
- WebSocket handler drives sessions through SessionOrchestrator instead of streamSessionAudio
- Client receives phase_start at the beginning of each of the 5 phases
- Client receives phase_transition between phases
- Audio continues to stream via synthesizeSentence per sentence
- Pause, resume, and end controls work as before
- Session pipeline error handling unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-state-machine-orchestration/05-03-SUMMARY.md`
</output>

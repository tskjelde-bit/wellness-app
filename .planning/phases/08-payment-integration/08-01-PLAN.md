---
phase: 08-payment-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/env.ts
  - src/lib/payment/ccbill-config.ts
  - src/lib/payment/checkout.ts
  - src/lib/payment/webhook-handler.ts
  - src/lib/payment/subscription.ts
  - src/lib/payment/index.ts
autonomous: true
requirements:
  - INFR-03

user_setup:
  - service: ccbill
    why: "High-risk payment processing for adult wellness content"
    env_vars:
      - name: CCBILL_ACCOUNT_NUMBER
        source: "CCBill Merchant Admin -> Account Info"
      - name: CCBILL_SUBACCOUNT
        source: "CCBill Merchant Admin -> Sub Account Settings"
      - name: CCBILL_FLEXFORM_ID
        source: "CCBill Merchant Admin -> FlexForms -> Form Name/ID"
      - name: CCBILL_SALT
        source: "CCBill Merchant Admin -> Webhooks -> Encryption Key/Salt"
    dashboard_config:
      - task: "Apply for CCBill merchant account"
        location: "https://www.ccbill.com/cs/signup"
      - task: "Create FlexForms payment form with monthly subscription pricing"
        location: "CCBill Merchant Admin -> FlexForms"
      - task: "Configure webhook URL to point to your deployed /api/webhooks/ccbill endpoint"
        location: "CCBill Merchant Admin -> Webhooks -> Add Webhook"
      - task: "Set success/failure return URLs in FlexForms config"
        location: "CCBill Merchant Admin -> FlexForms -> Return URLs"

must_haves:
  truths:
    - "Subscriptions and payment events are stored in PostgreSQL"
    - "CCBill checkout URL can be generated with user correlation"
    - "Webhook payloads are validated and dispatched to correct handlers"
    - "Subscription status can be queried for any user"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "subscriptions + payment_events tables"
      contains: "subscriptionsTable"
    - path: "src/lib/env.ts"
      provides: "CCBill environment variable validation"
      contains: "CCBILL_ACCOUNT_NUMBER"
    - path: "src/lib/payment/checkout.ts"
      provides: "FlexForms checkout URL generation"
      exports: ["generateCheckoutUrl"]
    - path: "src/lib/payment/webhook-handler.ts"
      provides: "Webhook parsing, verification, and event dispatch"
      exports: ["handleWebhookEvent"]
    - path: "src/lib/payment/subscription.ts"
      provides: "Subscription status queries"
      exports: ["hasActiveSubscription"]
  key_links:
    - from: "src/lib/payment/checkout.ts"
      to: "src/lib/payment/ccbill-config.ts"
      via: "imports CCBill config constants"
      pattern: "import.*ccbill-config"
    - from: "src/lib/payment/webhook-handler.ts"
      to: "src/lib/db/schema.ts"
      via: "inserts into subscriptions and payment_events"
      pattern: "db\\.insert\\(subscriptionsTable\\)"
    - from: "src/lib/payment/subscription.ts"
      to: "src/lib/db/schema.ts"
      via: "queries subscriptions table"
      pattern: "db\\.select.*subscriptionsTable"
---

<objective>
Create the payment backend foundation: database schema for subscriptions and payment events, CCBill configuration, checkout URL generation, webhook event handler, and subscription status queries.

Purpose: Establishes all server-side payment infrastructure that the webhook endpoint, subscribe UI, and access gating (Plan 02) will consume.
Output: Payment module at src/lib/payment/, extended schema, extended env validation.
</objective>

<execution_context>
@/Users/torbjorntest/.claude/get-shit-done/workflows/execute-plan.md
@/Users/torbjorntest/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-payment-integration/08-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/env.ts
@src/lib/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema and env validation for payment integration</name>
  <files>src/lib/db/schema.ts, src/lib/env.ts</files>
  <action>
    **Schema (src/lib/db/schema.ts):**
    Add two new tables after the existing consentRecordsTable:

    1. `subscriptionsTable` ("subscriptions"):
       - `id`: uuid, defaultRandom, primary key
       - `userId`: uuid, notNull, references usersTable.id with onDelete cascade
       - `ccbillSubscriptionId`: varchar(255), unique (CCBill's subscription identifier)
       - `ccbillTransactionId`: varchar(255) (initial transaction ID)
       - `status`: varchar(50), notNull, default "pending" — values: "pending", "active", "cancelled", "expired", "suspended"
       - `currentPeriodStart`: timestamp (mode: "date"), nullable
       - `currentPeriodEnd`: timestamp (mode: "date"), nullable
       - `cancelledAt`: timestamp (mode: "date"), nullable
       - `createdAt`: timestamp (mode: "date"), defaultNow, notNull
       - `updatedAt`: timestamp (mode: "date"), defaultNow, notNull

    2. `paymentEventsTable` ("payment_events"):
       - `id`: uuid, defaultRandom, primary key
       - `userId`: uuid, notNull, references usersTable.id with onDelete cascade
       - `eventType`: varchar(100), notNull — values: "NewSaleSuccess", "RenewalSuccess", "Cancellation", etc.
       - `ccbillTransactionId`: varchar(255), nullable
       - `payload`: text, nullable (full webhook JSON for audit trail)
       - `processedAt`: timestamp (mode: "date"), defaultNow, notNull

    **Env (src/lib/env.ts):**
    Add CCBill env vars to envSchema. These should be optional with `.optional()` since they are not needed for non-payment features and won't be available in early development:
    - `CCBILL_ACCOUNT_NUMBER`: z.string().min(1).optional()
    - `CCBILL_SUBACCOUNT`: z.string().min(1).optional()
    - `CCBILL_FLEXFORM_ID`: z.string().min(1).optional()
    - `CCBILL_SALT`: z.string().min(1).optional()

    Do NOT add CCBILL_SUCCESS_URL or CCBILL_FAILURE_URL — these will be derived from the request URL at runtime (e.g., `${origin}/subscribe/success`).

    Run `npx drizzle-kit generate` to create migration SQL.
  </action>
  <verify>
    - `npx drizzle-kit generate` produces a new migration file without errors
    - `npm run build` succeeds (schema imports resolve, env validation passes with existing vars)
    - New tables include proper foreign key references and constraints
  </verify>
  <done>
    subscriptionsTable and paymentEventsTable defined in schema.ts. CCBill env vars added to env.ts as optional fields. Migration SQL generated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create payment module with checkout, webhook handler, and subscription queries</name>
  <files>src/lib/payment/ccbill-config.ts, src/lib/payment/checkout.ts, src/lib/payment/webhook-handler.ts, src/lib/payment/subscription.ts, src/lib/payment/index.ts</files>
  <action>
    Create `src/lib/payment/` directory with five files:

    **ccbill-config.ts:**
    - Export constants: `CCBILL_FLEXFORMS_URL = "https://api.ccbill.com/wap-frontflex/flexforms"`
    - Export helper `getCcbillConfig()` that reads from process.env (not env.ts import, to match db/index.ts pattern for avoiding circular deps at build time) and returns `{ accountNumber, subaccount, flexformId, salt }`. Throw descriptive error if any are missing when called (lazy validation).

    **checkout.ts:**
    - Export `generateCheckoutUrl(userId: string, origin: string): string`
    - Builds CCBill FlexForms URL with query params: `formName` (flexformId), `clientAccnum` (accountNumber), `clientSubacc` (subaccount), `custom1` (userId for webhook correlation)
    - Append success/failure return URLs derived from origin: `${origin}/subscribe/success` and `${origin}/subscribe/failure`
    - Returns the full checkout URL string

    **webhook-handler.ts:**
    - Import db, subscriptionsTable, paymentEventsTable from schema
    - Export Zod schema `ccbillWebhookSchema` validating: `eventType` (enum of all CCBill event types: NewSaleSuccess, NewSaleFailure, RenewalSuccess, RenewalFailure, Cancellation, Expiration, Chargeback, Refund, Void), `subscriptionId` (optional string), `transactionId` (optional string), `custom1` (string — our userId), plus `.passthrough()` for additional CCBill fields
    - Export `verifyWebhookSignature(body: unknown, salt: string): boolean` — for v1, implement basic verification by checking that the payload has expected structure and the salt matches. Note in a comment that full HMAC verification should be implemented once CCBill's exact algorithm for JSON webhooks is confirmed during merchant onboarding.
    - Export `async function handleWebhookEvent(body: Record<string, unknown>): Promise<{ success: boolean; error?: string }>`:
      1. Parse body with ccbillWebhookSchema (return error if invalid)
      2. Get salt from getCcbillConfig()
      3. Verify signature (log warning but continue if verification fails in development)
      4. Extract userId from custom1
      5. Insert into paymentEventsTable (full payload as JSON string for audit)
      6. Switch on eventType:
         - "NewSaleSuccess": upsert subscription with status "active", set currentPeriodStart to now
         - "RenewalSuccess": update subscription status to "active", update currentPeriodEnd
         - "Cancellation" | "Expiration": update subscription status to "cancelled" or "expired", set cancelledAt
         - "Chargeback" | "Refund" | "Void": update subscription status to "suspended"
         - Default: log unknown event type, still record in payment_events
      7. Return { success: true }
    - Use Drizzle `db.insert().onConflictDoUpdate()` for subscription upsert keyed on ccbillSubscriptionId

    **subscription.ts:**
    - Import db, subscriptionsTable from schema
    - Import eq, and from drizzle-orm
    - Export `async function hasActiveSubscription(userId: string): Promise<boolean>`:
      - Query subscriptionsTable where userId matches AND status = "active", limit 1
      - Return boolean
    - Export `async function getSubscription(userId: string)`:
      - Query subscriptionsTable where userId matches, limit 1, order by createdAt desc
      - Return the subscription row or null
    - Export type `SubscriptionStatus = "pending" | "active" | "cancelled" | "expired" | "suspended" | "none"`
    - Export `async function getSubscriptionStatus(userId: string): Promise<SubscriptionStatus>`:
      - Call getSubscription, return status or "none" if no row

    **index.ts:**
    - Barrel export: `export { generateCheckoutUrl } from "./checkout"`, `export { handleWebhookEvent, ccbillWebhookSchema } from "./webhook-handler"`, `export { hasActiveSubscription, getSubscription, getSubscriptionStatus } from "./subscription"`, `export type { SubscriptionStatus } from "./subscription"`
  </action>
  <verify>
    - `npm run build` succeeds with no type errors
    - All 5 files exist under src/lib/payment/
    - TypeScript resolves all imports (schema, drizzle-orm, zod)
    - No circular dependency warnings
  </verify>
  <done>
    Payment module provides: checkout URL generation, webhook event handling with subscription lifecycle management, and subscription status queries. All functions are type-safe and use existing project patterns (Drizzle, Zod, barrel exports).
  </done>
</task>

</tasks>

<verification>
- Database schema has subscriptionsTable and paymentEventsTable with correct columns and foreign keys
- Environment validation includes CCBill vars as optional fields
- Migration SQL generated successfully
- Payment module exports: generateCheckoutUrl, handleWebhookEvent, hasActiveSubscription, getSubscription, getSubscriptionStatus
- `npm run build` passes with no errors
</verification>

<success_criteria>
- subscriptionsTable and paymentEventsTable are defined in schema.ts with proper relations
- CCBill env vars are validated (optional) in env.ts
- Payment module under src/lib/payment/ provides checkout, webhook handling, and subscription queries
- All code compiles without errors
- Migration SQL is generated
</success_criteria>

<output>
After completion, create `.planning/phases/08-payment-integration/08-01-SUMMARY.md`
</output>

---
phase: 04-tts-audio-streaming
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/ws/message-types.ts
  - src/lib/ws/session-handler.ts
  - src/lib/ws/index.ts
  - src/app/api/session/ws/route.ts
autonomous: true
requirements:
  - INFR-06

must_haves:
  truths:
    - "next-ws is installed and patches Next.js for WebSocket upgrade handling"
    - "WebSocket route at /api/session/ws accepts client connections"
    - "Binary audio frames and JSON control messages share the same WebSocket connection"
    - "Client can send start_session, pause, resume, and end messages"
    - "Server sends typed messages: session_start, text, session_end, error"
    - "WebSocket connection lifecycle handles open, message, and close events cleanly"
  artifacts:
    - path: "src/lib/ws/message-types.ts"
      provides: "Discriminated union types for WebSocket messages"
      exports: ["ServerMessage", "ClientMessage"]
    - path: "src/lib/ws/session-handler.ts"
      provides: "Session lifecycle manager for WebSocket connections"
      exports: ["handleSession"]
    - path: "src/lib/ws/index.ts"
      provides: "Barrel exports for WS module"
    - path: "src/app/api/session/ws/route.ts"
      provides: "WebSocket SOCKET handler endpoint"
      contains: "export function SOCKET"
  key_links:
    - from: "src/app/api/session/ws/route.ts"
      to: "src/lib/ws/session-handler.ts"
      via: "import handleSession"
      pattern: "import.*handleSession.*from.*@/lib/ws"
    - from: "src/lib/ws/session-handler.ts"
      to: "src/lib/ws/message-types.ts"
      via: "import message types"
      pattern: "import.*ServerMessage|ClientMessage.*from.*message-types"
---

<objective>
Set up the WebSocket gateway infrastructure using next-ws, define the message protocol, and create the session handler for managing WebSocket connection lifecycle.

Purpose: This is the real-time transport layer. The WebSocket gateway enables bidirectional communication between client and server -- audio flows out, control commands flow in. The session handler manages the full lifecycle of a streaming audio session.

Output: next-ws patching, WebSocket route handler, typed message protocol, session lifecycle manager.
</objective>

<execution_context>
@/Users/torbjorntest/.claude/get-shit-done/workflows/execute-plan.md
@/Users/torbjorntest/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-tts-audio-streaming/04-RESEARCH.md
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install next-ws and create WebSocket message protocol</name>
  <files>
    package.json
    src/lib/ws/message-types.ts
    src/lib/ws/index.ts
  </files>
  <action>
    1. Install dependencies:
       ```bash
       npm install next-ws ws
       npm install -D @types/ws
       ```

    2. Add next-ws patch to package.json scripts:
       - Add `"prepare": "next-ws patch"` to the scripts section
       - Run `npx next-ws patch` to apply the Next.js patch immediately

    3. Create `src/lib/ws/message-types.ts`:
       - Define `ServerMessage` discriminated union type:
         ```typescript
         export type ServerMessage =
           | { type: "session_start"; sessionId: string }
           | { type: "text"; data: string; index: number }
           | { type: "sentence_end"; index: number }
           | { type: "session_end" }
           | { type: "error"; message: string };
         ```
       - Define `ClientMessage` discriminated union type:
         ```typescript
         export type ClientMessage =
           | { type: "start_session"; prompt?: string }
           | { type: "pause" }
           | { type: "resume" }
           | { type: "end" };
         ```
       - Export a `parseClientMessage` function that safely parses a raw WebSocket message string into `ClientMessage | null` using a JSON.parse + type guard (return null if invalid format or unknown type)
       - Export a `serializeServerMessage` function that JSON.stringify's a `ServerMessage`
       - NOTE: Binary audio frames are sent as raw Uint8Array without JSON wrapping -- they are distinguished from JSON text frames by their binary opcode

    4. Create `src/lib/ws/index.ts`:
       - Barrel exports: all types and functions from message-types
  </action>
  <verify>
    - `npm ls next-ws` shows the package is installed
    - `npm ls ws` shows the package is installed
    - `npx tsc --noEmit` passes with no type errors
    - `grep "next-ws patch" package.json` confirms prepare script exists
  </verify>
  <done>
    next-ws and ws are installed, Next.js is patched for WebSocket support, and a type-safe message protocol with discriminated unions defines all client-server WebSocket messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket route handler and session handler</name>
  <files>
    src/lib/ws/session-handler.ts
    src/lib/ws/index.ts
    src/app/api/session/ws/route.ts
  </files>
  <action>
    1. Create `src/lib/ws/session-handler.ts`:
       - Import `WebSocket` type from `ws`
       - Import `parseClientMessage`, `serializeServerMessage`, `ServerMessage` from `./message-types`

       - Export `handleSession(client: WebSocket)` function:
         - Create an `AbortController` for this connection
         - Generate a `sessionId` using `crypto.randomUUID()`
         - Track session state: `isPaused: boolean`, `isStreaming: boolean`

         - Send initial `session_start` message with sessionId

         - Set up ping/pong heartbeat: `const pingInterval = setInterval(() => client.ping(), 30_000)` for keeping connection alive

         - Handle `client.on("message")`:
           - If message is a Buffer/ArrayBuffer, ignore (client should not send binary)
           - Parse text messages via `parseClientMessage(message.toString())`
           - If null (invalid), send error ServerMessage and return
           - Switch on message.type:
             - `"start_session"`: If already streaming, send error. Otherwise, set `isStreaming = true`. Import `streamSessionAudio` from `@/lib/tts` dynamically (lazy load to avoid circular deps at module level). Iterate the async generator:
               - For `sentence_start` events: send JSON `{ type: "text", data: event.text, index: event.index }`
               - For `audio` events: send `event.data` as binary frame via `client.send(event.data)`
               - For `sentence_end` events: send JSON `{ type: "sentence_end", index: event.index }`
               - For `session_end` events: send JSON `{ type: "session_end" }` and set `isStreaming = false`
               - Before each iteration, check `isPaused`: if paused, await a Promise that resolves when resumed (use a simple resolve callback pattern)
               - Pass `controller.signal` to streamSessionAudio for abort propagation
             - `"pause"`: Set `isPaused = true`
             - `"resume"`: Set `isPaused = false`, resolve the pause Promise
             - `"end"`: Call `controller.abort()`, send `session_end`, close client with code 1000

         - Handle `client.on("close")`:
           - Call `controller.abort()` to cancel any in-progress pipeline
           - Clear the ping interval
           - Log disconnection

         - Handle `client.on("error")`:
           - Call `controller.abort()`
           - Clear the ping interval
           - Log the error

    2. Create `src/app/api/session/ws/route.ts`:
       - Export `function SOCKET(client: import("ws").WebSocket, request: import("next/server").NextRequest)`:
         - Call `handleSession(client)`
         - NOTE: Authentication check deferred to Phase 5/6 (session state machine handles auth context). For now, accept all connections. Add a TODO comment noting auth requirement.
       - Export a GET handler that returns 426 Upgrade Required for non-WebSocket requests:
         ```typescript
         export function GET() {
           return new Response("WebSocket upgrade required", { status: 426 });
         }
         ```

    3. Update `src/lib/ws/index.ts`:
       - Add export of `handleSession` from session-handler
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - `grep "export function SOCKET" src/app/api/session/ws/route.ts` confirms WebSocket handler exists
    - `grep "handleSession" src/lib/ws/session-handler.ts` confirms session handler is exported
    - `grep "streamSessionAudio" src/lib/ws/session-handler.ts` confirms TTS pipeline integration
    - `grep "ping" src/lib/ws/session-handler.ts` confirms heartbeat
  </verify>
  <done>
    WebSocket route at /api/session/ws handles client connections. Session handler manages full lifecycle: start_session triggers audio pipeline, pause/resume control playback, end cleanly aborts. Ping/pong heartbeat keeps connections alive. AbortController propagates cancellation through the TTS pipeline.
  </done>
</task>

</tasks>

<verification>
- `npm ls next-ws ws` confirms both packages installed
- `npx tsc --noEmit` passes -- all WebSocket types resolve
- WebSocket route exists at src/app/api/session/ws/route.ts with SOCKET export
- Session handler connects to streamSessionAudio from TTS module
- Message protocol uses discriminated unions with type-safe parsing
- Ping/pong heartbeat configured at 30-second intervals
</verification>

<success_criteria>
1. next-ws is installed and patches Next.js for WebSocket upgrade handling
2. WebSocket route at /api/session/ws exports a SOCKET handler
3. Message protocol defines typed ServerMessage and ClientMessage discriminated unions
4. Session handler manages start/pause/resume/end lifecycle
5. Audio pipeline events are forwarded through WebSocket (JSON for metadata, binary for audio)
6. AbortController cancellation works on client disconnect or session end
7. TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-tts-audio-streaming/04-02-SUMMARY.md`
</output>

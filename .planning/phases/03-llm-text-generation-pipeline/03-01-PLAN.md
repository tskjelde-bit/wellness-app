---
phase: 03-llm-text-generation-pipeline
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/llm/sentence-chunker.ts
  - src/lib/llm/__tests__/sentence-chunker.test.ts
autonomous: true
requirements:
  - VOIC-02

must_haves:
  truths:
    - "Streaming text is split into complete sentences at natural boundaries (. ! ?)"
    - "Abbreviations like Dr. and Mr. do not cause premature sentence splits"
    - "Sentences shorter than the minimum length threshold are held in the buffer until more text arrives"
    - "Remaining text in the buffer is flushed when the stream ends"
  artifacts:
    - path: "src/lib/llm/sentence-chunker.ts"
      provides: "Sentence boundary splitting for streaming text"
      exports: ["splitAtSentenceBoundaries", "SplitResult", "ABBREVIATIONS"]
      min_lines: 30
    - path: "src/lib/llm/__tests__/sentence-chunker.test.ts"
      provides: "Test coverage for sentence boundary detection"
      min_lines: 40
  key_links:
    - from: "src/lib/llm/__tests__/sentence-chunker.test.ts"
      to: "src/lib/llm/sentence-chunker.ts"
      via: "import { splitAtSentenceBoundaries }"
      pattern: "splitAtSentenceBoundaries"
---

<objective>
Build a sentence boundary chunker that splits streaming text into complete sentences for natural TTS prosody.

Purpose: The LLM streams text as token fragments. Before safety filtering or TTS can process the text, it must be accumulated and split at natural sentence boundaries (. ! ?) with a minimum length threshold (~40 chars). This prevents short fragments, abbreviation-caused false splits, and ensures the final buffer is flushed on stream end.

Output: `src/lib/llm/sentence-chunker.ts` with full test coverage via TDD.
</objective>

<execution_context>
@/Users/torbjorntest/.claude/get-shit-done/workflows/execute-plan.md
@/Users/torbjorntest/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-llm-text-generation-pipeline/03-RESEARCH.md
</context>

<feature>
  <name>Sentence Boundary Chunker</name>
  <files>src/lib/llm/sentence-chunker.ts, src/lib/llm/__tests__/sentence-chunker.test.ts</files>
  <behavior>
    splitAtSentenceBoundaries(text: string, minLength?: number) -> SplitResult

    SplitResult = { complete: string[], remainder: string }

    Cases:
    - "Hello world. How are you? I am fine." (minLength=10) -> complete: ["Hello world.", "How are you?", "I am fine."], remainder: ""
    - "Hello world. Ho" (minLength=10) -> complete: ["Hello world."], remainder: "Ho"
    - "Dr. Smith will guide your breathing." (minLength=10) -> complete: ["Dr. Smith will guide your breathing."], remainder: ""
    - "Hi." (minLength=40) -> complete: [], remainder: "Hi."  (below min length)
    - "Take a deep breath in. Feel the calm." (minLength=40) -> complete: [], remainder: "Take a deep breath in. Feel the calm."  (neither segment meets minLength alone, but together the first sentence + second meet threshold after accumulation logic)
    - "Breathe in slowly through your nose! Now exhale gently." (minLength=10) -> complete: ["Breathe in slowly through your nose!", "Now exhale gently."], remainder: ""
    - "" -> complete: [], remainder: ""
    - "No punctuation here" -> complete: [], remainder: "No punctuation here"
    - "Mrs. Jones said hello. Let us begin." (minLength=10) -> complete: ["Mrs. Jones said hello.", "Let us begin."], remainder: ""
    - "e.g. this is an example. And more text." (minLength=10) -> complete: ["e.g. this is an example.", "And more text."], remainder: ""
    - "Wow!!! That was amazing." (minLength=10) -> complete: ["Wow!!!", "That was amazing."], remainder: ""

    Abbreviation allowlist: mr, mrs, ms, dr, prof, sr, jr, st, ave, blvd, dept, est, govt, i.e, e.g, vs, etc, approx, min, max, no, vol

    Default minLength: 40
  </behavior>
  <implementation>
    1. Create a Set of abbreviations (all lowercase).
    2. Use a regex to find sentence-ending punctuation ([.!?]+) followed by whitespace or end of string.
    3. For each match, extract the word before the period and check against abbreviation set.
    4. If abbreviation, skip the split.
    5. If the candidate sentence length >= minLength, push to complete array and advance the cut index.
    6. Return { complete, remainder } where remainder is everything after the last cut.

    Follow the research pattern in 03-RESEARCH.md Pattern 2 closely, but ensure the implementation handles all edge cases from the test cases above.
  </implementation>
</feature>

<verification>
- `npx vitest run src/lib/llm/__tests__/sentence-chunker.test.ts` passes all tests
- No TypeScript errors: `npx tsc --noEmit` succeeds
</verification>

<success_criteria>
- splitAtSentenceBoundaries correctly splits text at sentence boundaries
- Abbreviations (Dr., Mr., Mrs., e.g., etc.) do not cause false splits
- Minimum length threshold prevents emitting short fragments
- Empty input and no-punctuation input handled gracefully
- All test cases pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-llm-text-generation-pipeline/03-01-SUMMARY.md`
</output>
